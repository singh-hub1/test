PL/pgSQL CASE Statement:
=================================
==================================

Summary: in this tutorial, you will learn about the PL/pgSQL case that executes statements based on a certain condition.

Besides the if statement, PostgreSQL provides you with case statements that allow you to execute a block of code based on a condition.

The case statement selects a when section to execute from a list of when sections based on a condition.

The case statement has two forms:

Simple case statement
Searched case statement
Notice that you should not confuse about the case statement and case expression. The case expression evaluates to a value while the case statement selects a section to execute based on condition.

1) Simple case statement
Let’s start with the syntax of the simple case statement:
========
=======
case search-expression
   when expression_1 [, expression_2, ...] then
      when-statements
  [ ... ]
  [else
      else-statements ]
END case;
The search-expression is an expression that evaluates to a result.

The case statement compares the result of the search-expression with the expression in each when branch using equal operator ( =) from top to bottom.

If the case statement finds a match, it will execute the corresponding when section. Also, it stops comparing the result of the search-expression with the remaining expressions.

If the case statement cannot find any match, it will execute the else section.

The else section is optional. If the result of the search-expression does not match expression in the when sections and the else section does not exist, the case statement will raise a case_not_found exception.

The following is an example of the simple case statement.
EXAMPLE
=====
====
do $$
declare 
	rate   film.rental_rate%type;
	price_segment varchar(50);
begin
    -- get the rental rate
    select rental_rate into rate 
    from film 
    where film_id = 100;
	
	-- assign the price segment
	if found then
		case rate
		   when 0.99 then
              price_segment =  'Mass';
		   when 2.99 then
              price_segment = 'Mainstream';
		   when 4.99 then
              price_segment = 'High End';
		   else
	    	  price_segment = 'Unspecified';
		   end case;
		raise notice '%', price_segment;  
    end if;
end; $$
Output:

NOTICE:  High End
This example first selects the film with id 100. Based on the rental rate, it assigns a price segment to the film that can be mass, mainstream, or high end. In case the price is not 0.99, 2.99 or 4.99, the case statement assigns the film the price segment as unspecified.

The following flowchart illustrates the simple case statement in this example:

PL/pgSQL simple case statement

2) Searched case statement
The following syntax shows syntax of the searched case statement:

case
    when boolean-expression-1 then
      statements
  [ when boolean-expression-2 then
      statements
    ... ]
  [ else
      statements ]
end case;
In this syntax, the case statement evaluates the boolean expressions sequentially from top to bottom until it finds an expression that evaluates to true

Once it finds an expression that evaluates to true, the case statement executes the corresponding when section and immediately stops searching for the remaining expressions.

In case no expression evaluates to true, the case statement will execute the the else section.

The else section is optional. If you omit the else section and there is no expression evaluates to true, the case statement will raise the case_not_found exception.

The following example illustrates how to use a simple case statement:

do $$ 
declare
    total_payment numeric; 
    service_level varchar(25) ;
begin
     select sum(amount) into total_payment
     from Payment
     where customer_id = 100; 
	 
	 if found then
	    case 
		   when total_payment > 200 then
               service_level = 'Platinum' ;
           when total_payment > 100 then
	           service_level = 'Gold' ;
           else
               service_level = 'Silver' ;
        end case;
		raise notice 'Service Level: %', service_level;
     else
	    raise notice 'Customer not found';
	 end if;
end; $$ 
How it works:

First, select the total payment paid by the customer id 100 from the payment table.
Then, assign the service level to the customer based on the total payment
The following diagram illustrates the logic:

PL/pgSQL searched case statement

Notice that the searched case statement is similar to the if then elsif statement.

In this tutorial, you have learned how to use the PL/pgSQL case that execute statements based on a certain condition.

LOOP:
=====
====
PL/pgSQL Loop Statements

Summary: in this tutorial, you will learn about the PL/pgSQL loop statement that executes a block of code repeatedly.

Introduction to PL/pgSQL Loop statement
The loop defines an unconditional loop that executes a block of code repeatedly until terminated by an exit or return statement.

The following illustrates the syntax of the loop statement:

<<label>>
loop
   statements;
end loop;
Typically, you use an if statement inside the loop to terminate it based on a condition like this:

<<label>>
loop
   statements;
   if condition then
      exit;
   end if;
end loop;
It’s possible to place a loop statement inside another loop statement. When a loop statement is placed inside another loop statement, it is called a nested loop:

<<outer>>
loop 
   statements;
   <<inner>>
   loop
     /* ... */
     exit <<inner>>
   end loop;
end loop;
When you have nested loops, you need to use the loop label so that you can specify it in the exit and continue statement to indicate which loop these statements refer to.

PL/pgSQL loop statement example
The following example shows how to use the loop statement to calculate the Fibonacci sequence number.

do $$
declare
   n integer:= 10;
   fib integer := 0;
   counter integer := 0 ; 
   i integer := 0 ; 
   j integer := 1 ;
begin
	if (n < 1) then
		fib := 0 ;
	end if; 
	loop 
		exit when counter = n ; 
		counter := counter + 1 ; 
		select j, i + j into i,	j ;
	end loop; 
	fib := i;
    raise notice '%', fib; 
end; $$
Output:

NOTICE:  55
The block calculates the nth Fibonacci number of an integer (n).

By definition, Fibonacci numbers are a sequence of integers starting with 0 and 1, and each subsequent number is the sum of the two previous numbers, for example, 1, 1, 2 (1+1), 3 (2+1), 5 (3 +2), 8 (5+3), …

In the declaration section, the counter variable is initialized to zero (0). The loop is terminated when counter equals n. The following select statement swaps values of two variables i and j :

SELECT j, i + j INTO i,j ;


****PL/pgSQL While Loop********
================
=================


Summary: in this tutorial, you will learn about the PL/pgSQL while loop statement.

Introduction to PL/pgSQL while loop
The while loop statement executes a block of code until a condition evaluates to false.

[ <<label>> ]
while condition loop
   statements;
end loop;
In this syntax, PostgreSQL evaluates the condition before executing the statements.

If the condition is true, it executes the statements. After each iteration, the while loop evaluates the codition again.

Inside the body of the while loop, you need to change the values of some variables to make the condition false or null at some points. Otherwise, you will have an indefinite loop.

Because the while loop tests the condition before executing the statements, the while loop is sometimes referred to as a pretest loop.

The following flowchart illustrates the while loop statement.

PL/pgSQL WHILE loop
PL/pgSQL while loop example
The following example uses the while loop statement to display the value of a counter:

do $$
declare 
   counter integer := 0;
begin
   while counter < 5 loop
      raise notice 'Counter %', counter;
	  counter := counter + 1;
   end loop;
end$$;
Output:

NOTICE:  Counter 0
NOTICE:  Counter 1
NOTICE:  Counter 2
NOTICE:  Counter 3
NOTICE:  Counter 4
How it works.

First, declare the counter variable and initialize its value to 0.
Second, use the while loop statement to show the current value of the counter as long as it is less than 5. In each iteration, increase the value of counter by one. After 5 iterations, the counter is 5 therefore the while loop is terminated.
In this tutorial, you have learned how to use the PL/pgSQL while loop statement to execute a block of code as long as a condition is true.


********PL/pgSQL For Loop************
===================
====================

Summary: in this tutorial, you will learn about PL/pgSQL for loop statements to iterate over a range of integers or a result set of a query.

Using PL/pgSQL for loop to iterate over a range of integers
The following illustrates the syntax of the forloop statement that loops through a range of integers:

[ <<label>> ]
for loop_counter in [ reverse ] from.. to [ by step ] loop
    statements
end loop [ label ];
In this syntax:

First, the for loop creates an integer variable loop_counter which is accessible inside the loop only. By default, the for loop adds the step to the loop_counter after each iteration. However, when you use the reverse option, the for loop subtracts the step from loop_counter.
Second, the from and to are expressions that specify the lower and upper bound of the range. The for loop evaluates these expressions before entering the loop.
Third, the step that follows the by keyword specifies the iteration step. It defaults to 1. The for loop evaluates this step expression once only.
The following flowchart illustrates the for loop statement:

PL/pgSQL FOR loop
The following example uses the for loop statement to iterate over five numbers from 1 to 5 and display each of them in each iteration:

do $$
begin
   for counter in 1..5 loop
	raise notice 'counter: %', counter;
   end loop;
end; $$
Output:

NOTICE:  Counter: 1
NOTICE:  Counter: 2
NOTICE:  Counter: 3
NOTICE:  Counter: 4
NOTICE:  Counter: 5
The following example iterates over 5 numbers from 5 to 1 and shows each number in each iteration:

do $$
begin
   for counter in reverse 5..1 loop
      raise notice 'counter: %', counter;
   end loop;
end; $$
Output:

NOTICE:  Counter: 5
NOTICE:  Counter: 4
NOTICE:  Counter: 3
NOTICE:  Counter: 2
NOTICE:  Counter: 1
The following example uses the for loop statement to iterate over six numbers from 1 to 6. It adds 2 to the counter after each iteration:

do $$
begin 
  for counter in 1..6 by 2 loop
    raise notice 'counter: %', counter;
  end loop;
end; $$
Output:

NOTICE:  Counter 1
NOTICE:  Counter 3
NOTICE:  Counter 5
Using PL/pgSQL for loop to iterate over a result set
The following statement shows how to use the for loop statement to iterate over a result set of a query:

[ <<label>> ]
for target in query loop
    statements
end loop [ label ];
The following statement uses the for loop to display the titles of the top 10 longest films.

do
$$
declare
    f record;
begin
    for f in select title, length 
	       from film 
	       order by length desc, title
	       limit 10 
    loop 
	raise notice '%(% mins)', f.title, f.length;
    end loop;
end;
$$
NOTICE:  Chicago North(185 mins)
NOTICE:  Control Anthem(185 mins)
NOTICE:  Darn Forrester(185 mins)
NOTICE:  Gangs Pride(185 mins)
NOTICE:  Home Pity(185 mins)
NOTICE:  Muscle Bright(185 mins)
NOTICE:  Pond Seattle(185 mins)
NOTICE:  Soldiers Evolution(185 mins)
NOTICE:  Sweet Brotherhood(185 mins)
NOTICE:  Worst Banger(185 mins)
Using PL/pgSQL for loop to iterate over the result set of a dynamic query
The following form of the for loop statement allows you to execute a dynamic query and iterate over its result set:

[ <<label>> ]
for row in execute query_expression [ using query_param [, ... ] ] 
loop
    statements
end loop [ label ];
In this syntax:

The query_expression is an SQL statement.
The using clause is used to pass parameters to the query.
The following block shows how to use the for loop statement to loop through a dynamic query. It has two configuration variables:

sort_type: 1 to sort the films by title, 2 to sort the films by release year.
rec_count: is the number of rows to query from the film table. We’ll use it in the using clause of the for loop.
This anonymous block composes the query based on the sort_type variable and uses the for loop to iterate over the row of the result set.

do $$
declare
    -- sort by 1: title, 2: release year
    sort_type smallint := 1; 
	-- return the number of films
	rec_count int := 10;
	-- use to iterate over the film
	rec record;
	-- dynamic query
    query text;
begin
		
	query := 'select title, release_year from film ';
	
	if sort_type = 1 then
		query := query || 'order by title';
	elsif sort_type = 2 then
	  query := query || 'order by release_year';
	else 
	   raise 'invalid sort type %s', sort_type;
	end if;

	query := query || ' limit $1';

	for rec in execute query using rec_count
        loop
	     raise notice '% - %', rec.release_year, rec.title;
	end loop;
end;
$$
Output:

NOTICE:  2006 - Academy Dinosaur
NOTICE:  2006 - Ace Goldfinger
NOTICE:  2006 - Adaptation Holes
NOTICE:  2006 - Affair Prejudice
NOTICE:  2006 - African Egg
NOTICE:  2006 - Agent Truman
NOTICE:  2006 - Airplane Sierra
NOTICE:  2006 - Airport Pollock
NOTICE:  2006 - Alabama Devil
NOTICE:  2006 - Aladdin Calendar
If you change the sort_type to 2, you’ll get the following output:

NOTICE:  2006 - Grosse Wonderful
NOTICE:  2006 - Airport Pollock
NOTICE:  2006 - Bright Encounters
NOTICE:  2006 - Academy Dinosaur
NOTICE:  2006 - Ace Goldfinger
NOTICE:  2006 - Adaptation Holes
NOTICE:  2006 - Affair Prejudice
NOTICE:  2006 - African Egg
NOTICE:  2006 - Agent Truman
NOTICE:  2006 - Chamber Italian









****************PL/pgSQL Exit Statement*************
=====================
===================

Summary: in this tutorial, you will learn about the exit statement and how to use it to terminate a loop or a block.

Introduction to the PL/pgSQL Exit statement
The exit statement allows you to terminate a loop including an unconditional loop, a while loop, and a for loop.

The following shows the syntax of the exit statement:

exit [label] [when boolean_expression]
The label is the loop label of the current loop where the exit is in or the loop label of the outer loop. Depending on the label, the exit statement will terminate the corresponding loop. If you don’t use the label, the exit statement will terminate the current loop.

The when boolean_expression clause is used to specify a condition that terminates a loop. The exit statement will terminate the loop if the boolean_expression evaluates to true.

The following statements are equivalent:

exit when counter > 10;
if counter > 10 then
   exit;
end if;
The exit when is definitely cleaner and shorter.

In addition to terminating a loop, you can use the exit statement to terminate a block specified by the begin...end keywords. In this case, the control is passed to the statement after the end keyword of the current block:

<<block_label>>
BEGIN
    -- some code
    EXIT [block_label] [WHEN condition];
    -- some more code
END block_label;
PL/pgSQL Exit examples
Let’s take some examples of using the PL/pgSQL exit statement.

1) Using PL/pgSQL Exit statement to terminate an unconditional loop
The following example illustrates how to use the exit statement in unconditional loops:

do
$$
declare 
   i int = 0;
   j int = 0;
begin
  <<outer_loop>>
  loop 
     i = i + 1;
     exit when i > 3;
	 -- inner loop
	 j = 0;
     <<inner_loop>>
     loop 
		j = j + 1;
		exit when j > 3;
		raise notice '(i,j): (%,%)', i, j;
	 end loop inner_loop;
  end loop outer_loop;
end;
$$
Output:

NOTICE:  (i,j): (1,1)
NOTICE:  (i,j): (1,2)
NOTICE:  (i,j): (1,3)
NOTICE:  (i,j): (2,1)
NOTICE:  (i,j): (2,2)
NOTICE:  (i,j): (2,3)
NOTICE:  (i,j): (3,1)
NOTICE:  (i,j): (3,2)
NOTICE:  (i,j): (3,3)
How it works.

This example contains two loops: outer and inner loops.

Since both exit statements don’t use any loop labels, they will terminate the current loop.

The first exit statement terminates the outer loop when i is greater than 3. That’s why you see the value of i in the output is 1, 2, and 3.

The second exit statement terminates the inner loop when j is greater than 3. It is the reason you see that j is 1, 2, and 3 for each iteration of the outer loop.

The following example places the label of the outer loop in the second exit statement:

do
$$
declare 
   i int = 0;
   j int = 0;
begin
  <<outer_loop>>
  loop 
     i = i + 1;
     exit when i > 3;
	 -- inner loop
	 j = 0;
     <<inner_loop>>
     loop 
		j = j + 1;
		exit outer_loop when j > 3;
		raise notice '(i,j): (%,%)', i, j;
	 end loop inner_loop;
  end loop outer_loop;
end;
$$
Output:

NOTICE:  (i,j): (1,1)
NOTICE:  (i,j): (1,2)
NOTICE:  (i,j): (1,3)
In this example, the second exit statement terminates the outer loop when j is greater than 3.

2) Using the PL/pgSQL Exit statement to exit a block
The following example illustrates how to use the exit statement to terminate a block:

do
$$
begin
  
  <<simple_block>>  
   begin
  	 exit simple_block;
         -- for demo purposes
	 raise notice '%', 'unreachable!';
   end;
   raise notice '%', 'End of block';
end;
$$
Output

NOTICE:  End of block
In this example, the exit statement terminates the simple_block immediately:

exit simple_block;
This statement will never be reached:

raise notice '%', 'unreachable!';
Summary
Use exit statement to terminate a loop including an unconditional loop, while loop, and for loop.
Also use the exit statement to exit a block.











***************PL/pgSQL Continue************
===================
===================

Summary: in this tutorial, you will learn how to use the PL/pgSQL continue statement to control the loop.

Introduction to PL/pgSQL continue statement
The continue statement prematurely skips the current iteration of the loop and jumps to the next one. The continue statement can be used in all kinds of loops including unconditional loops, while loops, and for loops.

The following illustrates the syntax of the continue statement:

continue [loop_label] [when condition]
In this syntax, the loop_label and when condition are optional.

The loop_label is the label of the loop that you want to skip the current iteration. If you omit the loop_label, the continue statement skips the current iteration of the loop. If you specify a loop label, the continue statement skips the current iteration of that loop.

The condition is a boolean expression that specifies the condition to skip the current iteration of the loop. If the condition is true, then the continue will skip the current loop iteration.

PL/pgSQL Continue statement example
The following example uses the continue statement in an unconditional loop to print out the odd numbers from 1 to 10:

do
$$
declare
   counter int = 0;
begin
  
  loop
     counter = counter + 1;
	 -- exit the loop if counter > 10
	 exit when counter > 10;
	 -- skip the current iteration if counter is an even number
	 continue when mod(counter,2) = 0;
	 -- print out the counter
	 raise notice '%', counter;
  end loop;
end;
$$
Output:

NOTICE:  1
NOTICE:  3
NOTICE:  5
NOTICE:  7
NOTICE:  9
How it works.

First, initialize the counter to zero.
Second, increase the counter by one in each iteration. If the counter is greater than 10, then exit the loop. If the counter is an even number, then skip the current iteration.
The mod(counter,2) returns the remainder of the division of the counter by two. If it is zero, then the counter is an even number. All the statements between the continue statement and end loop will be skipped.

Summary
Use the continue statement to skip the current loop iteration prematurely and start a new one.











*************PostgreSQL Create Function Statement**********************
===========================================
============================================

Summary: in this tutorial, you will learn how to use the PostgreSQL CREATE FUNCTION statement to develop user-defined functions.

Introduction to Create Function statement
The create function statement allows you to define a new user-defined function.

The following illustrates the syntax of the create function statement:

create [or replace] function function_name(param_list)
   returns return_type 
   language plpgsql
  as
$$
declare 
-- variable declaration
begin
 -- logic
end;
$$
In this syntax:

First, specify the name of the function after the create function keywords. If you want to replace the existing function, you can use the or replace keywords.
Then, specify the function parameter list surrounded by parentheses after the function name. A function can have zero or many parameters.
Next, specify the datatype of the returned value after the returns keyword.
After that, use the language plpgsql to specify the procedural language of the function. Note that PostgreSQL supports many procedural languages, not just plpgsql.
Finally, place a block in the dollar-quoted string constant.
PostgreSQL Create Function statement examples
We’ll use the film table from the dvdrental sample database.


The following statement creates a function that counts the films whose length between the len_from and len_to parameters:

create function get_film_count(len_from int, len_to int)
returns int
language plpgsql
as
$$
declare
   film_count integer;
begin
   select count(*) 
   into film_count
   from film
   where length between len_from and len_to;
   
   return film_count;
end;
$$;
The function get_film_count has two main sections: header and body.

In the header section:

First, the name of the function is get_film_count that follows the create function keywords.
Second, the get_film_count() function accepts two parameters len_from and len_to with the integer datatype.
Third, the get_film_count function returns an integer specified by the returns int clause.
Finally, the language of the function is plpgsql indicated by the language plpgsql.
In the function body:

Use the dollar-quoted string constant syntax that starts with $$ and ends with $$. Between these $$, you can place a block that contains the declaration and logic of the function.
In the declaration section, declare a variable called film_count that stores the number of films selected from the film table.
In the body of the block, use the select into statement to select the number of films whose length are between len_from and len_to and assign the result to the film_count variable. At the end of the block, use the return statement to return the film_count.
To execute the create function statement, you can use any PostgreSQL client tool including psql and pgAdmin

1) Creating a function using pgAdmin
First, launch the pgAdmin tool and connect to the dvdrental sample database.

Second, open the query tool by selecting Tools > Query Tool.

Third, enter the above code int the query tool and click the Execute button to create the get_film_count function.


If everything is fine, you will see the following message:

CREATE FUNCTION

Query returned successfully in 44 msec.
It means that the function get_film_count is created successfully.

Finnally, you can find the function get_film_count in the Functions list:


In case you could not find the function name, you can right-click the Functions node and select Refresh… menu item to refresh the function list.

2) Creating a function using psql
First, launch the psql interactive tool and connect to the dvdrental database.

Second, enter the above code in the psql to create the function like this:

dvdrental=# create function get_film_count(len_from int, len_to int)
dvdrental-# returns int
dvdrental-# language plpgsql
dvdrental-# as
dvdrental-# $$
dvdrental$# declare
dvdrental$#    film_count integer;
dvdrental$# begin
dvdrental$#    select count(*)
dvdrental$#    into film_count
dvdrental$#    from film
dvdrental$#    where length between len_from and len_to;
dvdrental$#
dvdrental$#    return film_count;
dvdrental$# end;
dvdrental$# $$;
You will see the following message if the function is created successfully:

CREATE FUNCTION
Third, use the \df command to list all user-defined in the current database:

dvdrental=# \df
Calling a user-defined function
PostgreSQL provides you with three ways to call a user-defined function:

Using positional notation
Using named notation
Using mixed notation.
1) Using positional notation
To call a function using the positional notation, you need to specify the arguments in the same order as parameters. For example:

select get_film_count(40,90);
Output:

 get_film_count
----------------
            325
(1 row)
In this example, the arguments of the get_film_count() are 40 and 90 that corresponding to the from_len and to_len parameters.

You call a function using the positional notation when the function has few parameters.

If the function has many parameters, you should call it using the named notation since it will make the function call more obvious.

2) Using positional notation
The following shows how to call the get_film_count function using the positional notation:

select get_film_count(
    len_from => 40, 
     len_to => 90
);
Output:

 get_film_count
----------------
            325
(1 row)
In the named notation, you use the => to separate the argument’s name and its value.

For backward compatibility, PostgreSQL supports the older syntax based on := as follows:

select get_film_count(
    len_from := 40, 
    len_to := 90
);
3) Using mixed notation
The mixed notation is the combination of positional and named notations. For example:

select get_film_count(40, len_to => 90);
Note that you cannot use the named arguments before positional arguments like this:

select get_film_count(len_from => 40, 90);
Error:

ERROR:  positional argument cannot follow named argument
LINE 1: select get_film_count(len_from => 40, 90);
In this tutorial, you have learned how to use the CREATE FUNCTION statement to create a user-defined function.











*************PL/pgSQL Function Parameter Modes: IN, OUT, INOUT***************
=========================================
========================================

Summary: in this tutorial, you will learn about parameter modes of functions including: in, out, and inout.

Introduction to PL/pgSQL parameter modes
The parameter modes determine the behaviors of parameters. PL/pgSQL supports three parameter modes: in, out, and inout. A parameter takes the in mode by default if you do not explicitly specify it.

The following table illustrates the three parameter modes:

IN	OUT	INOUT
The default	Explicitly specified	Explicitly specified
Pass a value to function	Return a value from a function	Pass a value to a function and return an updated value.
in parameters act like constants	out parameters act like uninitialized variables	inout parameters act like an initialized variables
Cannot be assigned a value	Must assign a value	Should be assigned a value
**********************The IN mode
The following function finds a film by its id and returns the title of the film:

create or replace function find_film_by_id(p_film_id int)
returns varchar
language plpgsql
as $$
declare
   film_title film.title%type;
begin
  -- find film title by id
  select title 
  into film_title
  from film
  where film_id = p_film_id;
  
  if not found then
     raise 'Film with id % not found', p_film_id;
  end if;
  
  return title;
  
end;$$
Because we didn’t specify the mode for p_film_id parameter, it takes the in mode by default.

*****************The OUT mode
The out parameters are defined as a part of the argument list and are returned back as a part of the result.

The out parameters are very useful in functions that need to return multiple values.

Note that PostgreSQL has supported the out parameters since version 8.1.

To define out parameters, you explicitly precede the parameter name with the out keyword as follows:

out parameter_name type
The following example defines the get_film_stat function that has three out parameters:

create or replace function get_film_stat(
    out min_len int,
    out max_len int,
    out avg_len numeric) 
language plpgsql
as $$
begin
  
  select min(length),
         max(length),
		 avg(length)::numeric(5,1)
  into min_len, max_len, avg_len
  from film;

end;$$
In the get_film_stat function, we select the min, max, and average of film length from the film table using the min, max, and avg aggregate functions and assign the results to the corresponding out parameters.

The following statement calls the get_film_stat function:

select get_film_stat();

The output of the function is a record. To make the output separated as columns, you use the following statement:

select * from get_film_stat();

************************The INOUT mode
The inout mode is the combination in and out modes.

It means that the caller can pass an argument to a function. The function changes the argument and returns the updated value.

The following swap function accepts two integers and their values:

create or replace function swap(
	inout x int,
	inout y int
) 
language plpgsql	
as $$
begin
   select x,y into y,x;
end; $$;
The following statement calls the square() function:

select * from square(10,20);

Summary
PL/pgSQL support three parameter modes: in, out, and intout. By default, a parameter takes the in mode.
Use the in mode if you want to pass a value to the function.
Use the out mode if you want to return a value from a function.
Use the inout mode when you want to pass in an initial value, update the value in the function, and return it updated value back.











*************************PL/pgSQL Function Overloading********************
==============================================
======================================

Summary: in this tutorial, you will learn about function overloading in PostgreSQL.

Introduction to PL/pgSQL Function Overloading
PostgreSQL allows multiple functions to share the same name as long as they have different arguments.

If two or more functions share the same name, the function names are overloaded.

When you can call an overloading function, PostgreSQL select the best candidate function to execute based on the the function argument list.

The following get_rental_duration() function returns the total rental days of a specified customer:

create or replace function get_rental_duration(
	p_customer_id integer
)
returns integer 
language plpgsql
as $$
declare 
	rental_duration integer; 
begin
	select 
		sum( extract(day from return_date - rental_date)) 
	into rental_duration 
    from rental 
	where customer_id = p_customer_id;

	return rental_duration;
end; $$
The get_rental_function function has the p_customer_id as an in parameter.

The following return the number of rental days of the customer id 232:

SELECT get_rental_duration(232);
 get_rental_duration
---------------------
                  90
(1 row)
Suppose that you want to know the rental duration of a customer from a specific date up to now.

To do it, you can add one more parameter p_from_date to the get_retal_duration() function. Or you can develop a new function with the same name but have two parameters like this:

create or replace function get_rental_duration(
	p_customer_id integer, 
	p_from_date date
)
returns integer 
language plpgsql
as $$
declare 
	rental_duration integer;
begin
	-- get the rental duration based on customer_id 
	-- and rental date
	select sum( extract( day from return_date + '12:00:00' - rental_date)) 
	into rental_duration
	from rental 
	where customer_id = p_customer_id and 
		  rental_date >= p_from_date;
	
	-- return the rental duration in days
	return rental_duration;
end; $$
This function has the same name as the first one except that it has two parameters.

In other words, the get_rental_duration(integer) function is overloaded by the get_rental_duration(integer,date) function.

The following statement returns the rental duration of the customer id 232 since July 1st 2005:

SELECT get_rental_duration(232,'2005-07-01');
 get_rental_duration
---------------------
                  85
(1 row)
Note that if you omit the second argument, PostgreSQL will call the get_rental_duration(integer) function that has one parameter.

PL/pgSQL function overloading and default values
In the get_rental_duration(integer,date) function, if you want to set a default value to the second argument like this:

create or replace function get_rental_duration(
	p_customer_id integer, 
	p_from_date date default '2005-01-01'
)
returns integer
language plpgsql
as $$
declare 
	rental_duration integer;
begin
	select sum( 
		extract( day from return_date + '12:00:00' - rental_date)
	) 
	into rental_duration
	from rental 
	where customer_id= p_customer_id and 
		  rental_date >= p_from_date;
	 
	return rental_duration;

end; $$
The following calls the get_rental_duration() function and passes the customer id 232:

SELECT get_rental_duration(232);
PostgreSQL issued an error:

ERROR:  function get_rental_duration(integer) is not unique
LINE 1: SELECT get_rental_duration(232);
               ^
HINT:  Could not choose the best candidate function. You might need to add explicit type casts.
SQL state: 42725
Character: 8
In this case, PostgreSQL could not choose the best candidate function to execute.

In this scenario, you have three functions:

get_rental_duration(p_customer_id integer);
get_rental_duration(p_customer_id integer, p_from_date date)
get_rental_duration(p_customer_id integer, p_from_date date default '2005-01-01'
)
PostgreSQL did not know whether it should execute the first or the third function.

As a rule of thumb, when you overload a function, you should always make their parameter list unique.

Summary
Multiple functions can share the same names as long as they have different arguments. These function names are overloaded.
Use a unique function argument list to define overloading functions.












*******How to Develop a PL/pgSQL Function That Returns a Table
===============================================

Summary: in this tutorial, you will learn how to develop PostgreSQL functions that return a table.

To define a function that returns a table, you use the following form of the create function statement:

create or replace function function_name (
   parameter_list
) 
returns table ( column_list ) 
language plpgsql
as $$
declare 
-- variable declaration
begin
-- body
end; $$ 
Instead of returning a single value, this syntax allows you to return a table with a specified column list:

returns table ( column_list ) 
We will use the film table from the sample database for the demonstration:


The following function returns all films whose titles match a particular pattern using ILIKE operator.

create or replace function get_film (
  p_pattern varchar
) 
	returns table (
		film_title varchar,
		film_release_year int
	) 
	language plpgsql
as $$
begin
	return query 
		select
			title,
			release_year::integer
		from
			film
		where
			title ilike p_pattern;
end;$$
This get_film(varchar) accepts one parameter p_pattern which is a pattern that you want to match with the film title.

The function returns a query that is the result of a select statement. Note that the columns in the result set must be the same as the columns in the table defined after the returns table clause.

Because the data type of release_year column from the film table is not integer, you need to cast it to an integer using the cast operator ::.

The folowing shows how to call the get_film() function:

SELECT * FROM get_film ('Al%');
Output:


If you call the function using the following statement, PostgreSQL returns a table that consists of one column that holds an array of rows:

SELECT get_film ('Al%');
Output:


In practice, you often process each individual row before appending it in the function’s result set:

create or replace function get_film (
	p_pattern varchar,
	p_year int
) 
returns table (
	film_title varchar,
	film_release_year int
) 
language plpgsql
as $$
declare 
    var_r record;
begin
	for var_r in(
            select title, release_year 
            from film 
	     where title ilike p_pattern and 
		    release_year = p_year
        ) loop  film_title := upper(var_r.title) ; 
		film_release_year := var_r.release_year;
           return next;
	end loop;
end; $$ 
In this example, we created the get_film(varchar,int) that accepts two parameters:

The p_pattern is used to search for films.
The p_year is the release year of the films.
In the function body, we used a for loop staetment to process the query row by row.

The return next statement adds a row to the returned table of the function.

The following illustrates how to call the get_film() function:

SELECT * FROM get_film ('%er', 2006);

Note that this example is for the demonstration purposes.

Summary
Use the returns table (column_list) in the create function to define a function that returns a table (or result set).









*****************PostgreSQL Drop Function***************
===================
=====================
Summary: in this tutorial, you will learn how to use the PostgreSQL drop function statement to remove a function.

Introduction to PostgreSQL Drop Function statement
To remove a user-defined function, you use the drop function statement:

drop function [if exists] function_name(argument_list)
[cascade | restrict]
In this syntax:

First, specify the name of the function that you want to remove after the drop function keywords.
Second, use the if exists option if you want to instruct PostgreSQL to issue a notice instead of an error in case the function does not exist.
Third, specify the argument list of the function. Since functions can be overloaded, PostgreSQL needs to know which function you want to remove by checking the argument list. If a function is unique within the schema, you do not need to specify the argument list.
When a function has any dependent objects such as operators or triggers, you cannot drop that function.

To drop the function and its dependent objects, you need to specify the cascade option. The drop function with cacade option will recursively remove the function, its dependent objects, and the objects that depend on those objects, and so on.

By default, the drop function statement uses the restrict option that rejects the removal of a function when it has any dependent objects.

To drop multiple functions using a single drop function statement, you specify a comma-separated list of function name after the drop function keyword like this:

drop function [if exists] function1, function2, ...;
PostgreSQL Drop Function examples
The following statement uses the create function statement to define a function that returns a set of films including film_id, title, and actor:

create or replace function get_film_actors()
	returns setof record
as $$
declare
   rec record;
begin
   for rec in select 
			film_id, 
			title, 
            (first_name || ' ' || last_name)::varchar
		from film
		inner join film_actor using(film_id)
		inner join actor using (actor_id)
		order by title
	loop
        return next rec;
	end loop;
	
	return;
end;
$$ 
language plpgsql;
The following statement defines a function with the same name get_film_actors. However, it accepts a film id as the argument:

create or replace function get_film_actors(p_fiml_id int)
	returns setof record
as $$
declare
   rec record;
begin
   for rec in select 
			film_id, 
			title, 
            (first_name || ' ' || last_name)::varchar
		from film
		inner join film_actor using(film_id)
		inner join actor using (actor_id)
		where film_id = p_fiml_id
		order by title
	loop
        return next rec;
	end loop;
	
	return;
end;
$$ 
language plpgsql;
The following statement attempts to drop the get_film_actors function:

drop function get_film_actors;
However, PostgreSQL issued an error:

ERROR:  function name "get_film_actors" is not unique
HINT:  Specify the argument list to select the function unambiguously.
SQL state: 42725
Since the get_film_actors stored procedure is not unique, you need to specify which function you want to drop.

The following statement drops the get_film_actors function that has zero parameters:

drop function get_film_actors();
Now, there is only one get_film_actors function left. Since it is unique in the database, you can drop it without specifying its argument list like this:

drop function get_film_actors;
Or if you want to specify the exact function, you can use the following statement:

drop function get_film_actors(int);
Summary
Use drop function statement to remove a function.
Specify the argument list in the function if the function is overloaded.
Use the drop function statement with the cascade option to drop a function and its dependent objects and objects that depends on those objects, and so on.











******************PostgreSQL CREATE PROCEDURE***********************
==================================
===================================

Summary: in this tutorial, you will learn how to use the PostgreSQL CREATE PROCEDURE statement to create new stored procedures.

Introduction to PostgreSQL CREATE PROCEDURE statement
So far, you have learned how to define user-defined functions using the create function statement.

A drawback of user-defined functions is that they cannot execute transactions. In other words, inside a user-defined function, you cannot start a transaction, and commit or rollback it.

PostgreSQL 11 introduced stored procedures that support transactions.

To define a new stored procedure, you use the create procedure statement.

The following illustrates the basic syntax of the create procedure statement:

create [or replace] procedure procedure_name(parameter_list)
language plpgsql
as $$
declare
-- variable declaration
begin
-- stored procedure body
end; $$
In this syntax:

First, specify the name of the stored procedure after the create procedure keywords.
Second, define parameters for the stored procedure. A stored procedure can accept zero or more parameters.
Third, specify plpgsql as the procedural language for the stored procedure. Note that you can use other procedural languages for the stored procedure such as SQL, C, etc.
Finally, use the dollar-quoted string constant syntax to define the body of the stored procedure.
Parameters in stored procedures can have the in and inout modes. They cannot have the out mode.

A stored procedure does not return a value. You cannot use the return statement with a value inside a store procedure like this:

return expression;
However, you can use the return statement without the expression to stop the stored procedure immediately:

return;
If you want to return a value from a stored procedure, you can use parameters with the inout mode.

PostgreSQL CREATE PROCEDURE statement examples
We will use the following accounts table for the demonstration:

drop table if exists accounts;

create table accounts (
    id int generated by default as identity,
    name varchar(100) not null,
    balance dec(15,2) not null,
    primary key(id)
);

insert into accounts(name,balance)
values('Bob',10000);

insert into accounts(name,balance)
values('Alice',10000);
The following statement shows the data from the accounts table:

select * from accounts;

The following example creates a stored procedure named transfer that transfers a specified amount of money from one account to another.

create or replace procedure transfer(
   sender int,
   receiver int, 
   amount dec
)
language plpgsql    
as $$
begin
    -- subtracting the amount from the sender's account 
    update accounts 
    set balance = balance - amount 
    where id = sender;

    -- adding the amount to the receiver's account
    update accounts 
    set balance = balance + amount 
    where id = receiver;

    commit;
end;$$
Calling a stored procedure
To call a stored procedure, you use the CALL statement as follows:

call stored_procedure_name(argument_list);
For example, this statement invokes the transfer stored procedure to transfer $1,000 from Bob’s account to Alice’s account.

call transfer(1,2,1000);
The following statement verifies the data in the accounts table after the transfer:

SELECT * FROM accounts;

It worked as expected.

Summary
Use create procedure statement to define a new stored procedure.
Use the call statement to invoke a stored procedure.


*************PostgreSQL Drop Procedure************
===================================

Summary: in this tutorial, you will learn how to use the PostgreSQL drop procedure statement to remove a procedure.

Introduction to PostgreSQL Drop Procedure statement
The drop procedure statement removes a stored procedure. The following illustrates the syntax of the drop procedure statement:

drop procedure [if exists] procedure_name (argument_list)
[cascade | restrict]
In this syntax:

First, specify the name (procedure_name) of the stored procedure that you want to remove after the drop procedure keywords.
Second, use the if exists option if you want PostgreSQL to issue a notice instead of an error if you drop a stored procedure that does not exist.
Third, specify the argument list of the stored procedure if the stored procedure’s name is not unique in the database. Note that stored procedures that have different argument lists can share the same name. PostgreSQL needs the argument list to determine which stored procedure that you want to remove.
Finally, use the cascade option to drop the stored procedures and its dependent objects and the objects that depend on those objects and so on. The default option is restrict that will reject the removal of the stored procedure in case it has any dependent objects.
To drop multiple stored procedures, you specify a comma-list of stored procedure names after the drop procedure keyword like this:

drop procedure [if exists] name1, name2, ...;
Creating sample stored procedures
Let’s create a couple of stored procedures that manage actors so that you can learn how to drop them:


The following insert_actor() stored procedure inserts a new row into the actor table. It accepts two arguments which are the first name and last name of the actor.

create or replace procedure insert_actor(
	fname varchar, 
	lname varchar)
language plpgsql	
as $$
begin
	insert into actor(first_name, last_name)
	values('John','Doe');
end;
$$;
The following insert_actor stored procedure also inserts a row into the actor table. However, it accepts one argument which is the full name of the actor. The insert_actor() uses the split_part() function to split the full name into first name and last name before inserting them into the actor table.

create or replace procedure insert_actor(
	full_name varchar
)
language plpgsql	
as $$
declare
	fname varchar;
	lname varchar;
begin
	-- split the fullname into first & last name
	select 
		split_part(full_name,' ', 1),
		split_part(full_name,' ', 2)
	into fname,
	     lname;
	
	-- insert first & last name into the actor table
	insert into actor(first_name, last_name)
	values('John','Doe');
end;
$$;
The following stored procedure deletes an actor by id:

create or replace procedure delete_actor(
	p_actor_id int
)
language plpgsql
as $$
begin
	delete from actor 
	where actor_id = p_actor_id;
end; 
$$;
And the following stored procedure updates the first name and last name of an actor:

create or replace procedure update_actor(
	p_actor_id int,
	fname varchar,
	lname varchar
)
language plpgsql
as $$
begin
	update actor 
	set first_name = fname,
	    last_name = lname
	where actor_id = p_actor_id;
end; 
$$;
PostgreSQL Drop Procedure examples
First, attempt to drop theinsert_actor stored procedure:

drop procedure insert_actor;
PostgreSQL issued the following error:

ERROR:  procedure name "insert_actor" is not unique
HINT:  Specify the argument list to select the procedure unambiguously.
SQL state: 42725
Because there are two insert_actor stored procedures, you need to specify the argument list so that PostgreSQL can select the right stored procedure to drop.

Second, drop the insert_actor(varchar) stored procedure that accepts one argument:

drop procedure insert_actor(varchar);
Since the insert_actor stored procedure is unique now, you can drop it without specifying the argument list:

drop procedure insert_actor;
It is the same as:

drop procedure insert_actor(varchar,varchar);
Third, drop two stored procedures using a single drop procedure statement:

drop procedure 
	delete_actor, 
	update_actor;
Summary
Use the drop procedure statement to remove a stored procedure.
Specify a comma-separated list of stored procedure names after the drop procedure keywords to drop multiple stored procedures.
If the stored procedure name is not unique, use the argument list to specify which stored procedure you want to drop

